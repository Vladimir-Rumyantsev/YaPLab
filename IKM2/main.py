# Вариант 4. Румянцев Владимир ПМИ-10.

class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None


class Stack:
    def __init__(self):
        self.head = None
        self.n = 1                                    # Число n для временных переменных Tn
        self.free_names = []                          # Пополняется освободившимися Tn

    def get_name_of_temp_var(self, var1, var2):       # Функция получения имени для временной переменной Tn
        if (len(var1) > 1) and (var1[0] == 'T'):      # Если первый операнд в формате Tn, ...
            try:
                a = int(var1[1:])
                if a < self.n:
                    self.free_names.append(var1)      # ... то пополнить им список освободившихся Tn
            except ValueError:
                pass

        if (len(var2) > 1) and (var2[0] == 'T'):      # Если второй операнд в формате Tn, ...
            try:
                a = int(var2[1:])
                if a < self.n:
                    self.free_names.append(var2)      # ... то пополнить им список освободившихся Tn
            except ValueError:
                pass

        if self.free_names:                           # Если в списке освободившихся Tn что-то есть,
            return self.free_names.pop(0)             # то вернуть первый элемент

        temp_var = f'T{self.n}'                       # Если освободившихся имён нет, то создать и вернуть новое имя,
        self.n += 1                                   # исходя из "self.n". Так-же увеличить "self.n" на 1
        return temp_var

    def push(self, new_data=None):                    # Добавление в стек нового элемента
        if not (new_data in '*/+-'):                  # Если это операнд, то просто добавить его в стек
            new_node = Node(new_data)
            new_node.next = self.head
            self.head = new_node
            return ''                                 # Возвращаем пустую строку

        else:                                         # Если это операция...
            if new_data == '+':
                operation = 'AD'
            elif new_data == '-':
                operation = 'SB'
            elif new_data == '*':
                operation = 'ML'
            else:
                operation = 'DV'

            try:
                variable_1 = self.head.next.data      # Получить данные первого и второго операндов
                variable_2 = self.head.data
            except AttributeError:                    # В стеке не хватает операндов, вызвать ошибку и окончить работу
                raise Exception(f'Во время работы программы произошла ошибка из-за нехватки переменных для работы.\n'
                                f'Такая ошибка происходит, например, когда на вход программе подано такое выражение: '
                                f'"A+", вместо такого "AB+".\nПерепроверьте ваше выражение и введите его корректно.')

            temp_var = self.get_name_of_temp_var(variable_1, variable_2)   # Получить имя для временной переменной

            line = f'LD {variable_1}\n{operation} {variable_2}\nST {temp_var}\n'   # Перечень инструкций
            new_node = Node(temp_var)                            # Помещение временной переменной в стек
            new_node.next = self.head.next.next                  # Переопределение ссылок для удаления операндов
            self.head = new_node
            return line                                          # Возвращаем перечень инструкций


def main(input_data):                                 # Главная функция, на входе получает выражение в постфиксной форме
    stack = Stack()
    line = ''

    for i in input_data:                              # Проходимся по каждому элементу в строке входных данных
        line += stack.push(i)                         # В line дописываем результат функции push (конкретные инструкции)

    res_line = ''                                     # Создание переменной для итогового ответа пользователю

    try:                                              # Проверка на то, остались ли элементы в стеке,
        current = stack.head.next                     # в норме останется только один элемент
        if current:                                   # Если элементов в стеке осталось больше одного, ...
            res_line = f'\nПрограмма окончила работу с лишним(и) операндом(ами) в регистре: '
            while current:                            # ... то сообщим об этом в итоговом ответе
                res_line += f'"{current.data}", '
                current = current.next
            res_line = (f'{res_line[:-2]}.\n'
                        f'Это связано с излишним их количеством на входе (например, было подано выражение "ABC+").\n'
                        f'Совет: В случае, если вы не уверены в корректности вашего запроса - перепроверьте выражение, '
                        f'которое было подано программе на вход и запросите новый результат!\n')

    except AttributeError:                            # Ошибка произошла из-за отсутствия в стеке даже одного элемента,
        pass                                          # Значит пользователь дал на вход пустую стоку

    for i in range(len(line) - 2, -1, -1):            # Т.к. согласно условию результат вычислений остаётся в регистре,
        if (line[i] == 'S') and (line[i + 1] == 'T'):         # нужно избавиться от последней инструкции ST
            res_line += f'\nРезультат:\n{line[:i].strip()}'   # В переменную с конечным ответом записываем результат
            break

    if not res_line:                                  # Результат отсутствует, т.к. на вход пришла пустая строка
        print('Результат отсутствует!\n'
              'Пожалуйста, перепроверьте корректность вашего выражения и запросите новый результат.')
    else:
        print(res_line)                               # Сообщить пользователю итог (перечень инструкций)


if __name__ == '__main__':
    user_input = input('\nВведите выражение в постфиксной форме (пример: ABC*+): ')   # Ввод пользователя
    while True:
        try:
            main(user_input)                          # Начало работы с данными от пользователя
        except Exception as ex:                       # В случае ошибки, о ней сообщаем пользователю
            print(ex)
        finally:                                      # Вне зависимости от результата, просим новое выражение
            user_input = input('\n----------------------------------------------------------------'
                               '----------------------------------------------------------------\n'
                               '\nВведите новое выражение: ')

# Пример входных данных: ABC*+DE-/
# Выходные данные:
# Результат:
# LD B
# ML C
# ST T1
# LD A
# AD T1
# ST T1
# LD D
# SB E
# ST T2
# LD T1
# DV T2

# Пример входных данных: AB
# Выходные данные:
# Программа окончила работу с лишним(и) операндом(ами) в регистре: "A".
# Это связано с излишним их количеством на входе (например, было подано выражение "ABC+").
# Совет: В случае, если вы не уверены в корректности вашего запроса - перепроверьте выражение,
# которое было подано программе на вход и запросите новый результат!

# Пример входных данных: +
# Выходные данные:
# Во время работы программы произошла ошибка из-за нехватки переменных для работы.
# Такая ошибка происходит, например, когда на вход программе подано такое выражение: "A+", вместо такого "AB+".
# Перепроверьте ваше выражение и введите его корректно.
