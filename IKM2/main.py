# Вариант 4. Румянцев Владимир ПМИ-10.

class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

    def __str__(self):
        return str(self.data)


class LinkedList:                                     # Односвязный список
    def __init__(self):
        self.head = None

    def __str__(self) -> str:        # Красивое написание всего списка (все элементы через запятую в квадратных скобках)
        current = self.head
        line = ''
        while current:
            line += f'{current.data}, '
            current = current.next
        return f'[{line[:-2]}]'

    def __len__(self) -> int:                         # Узнать количество элементов в списке
        current = self.head
        count = 0
        while current:
            current = current.next
            count += 1
        return count

    def push(self, new_data):                         # Добавить в начало списка новый элемент
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    def add(self, new_data):                          # Добавить в конец списка новый элемент
        if not self.head:
            self.head = Node(new_data)
            return

        current = self.head
        while current.next:
            current = current.next
        current.next = Node(new_data)

    def pop(self, index: int):                        # Удалить элемент по индексу, вернуть значение удаляемого элемента
        if (index > len(self) - 1) or (index < 0):    # Если такого индекса в списке нет - вернуть None
            return None

        if index == 0:                              # Если удаляется первый элемент - нужно переопределить начало списка
            a = self.head.data
            self.head = self.head.next
            return a

        current = self.head
        position = 1
        while current.next and (position < index):    # Находим элемент перед удаляемым
            current = current.next
            position += 1
        a = current.next.data              # Записываем значение удаляемого элемента (current - элемент перед удаляемым)
        current.next = current.next.next              # Переопределяем ссылки элемента перед удаляемым
        return a                                      # Возвращаем значение удаляемого элемента


class Stack:                                          # Стек - объект для хранения всей необходимой информации
    def __init__(self):
        self.list = LinkedList()                      # Тут будут храниться операнды
        self.n = 1                                    # Число n для временных переменных Tn
        self.free_names = LinkedList()                # Пополняется освободившимися именами Tn

    def get_name_of_temp_var(self, var1, var2):       # Функция получения имени для временной переменной Tn
        if (len(var1) > 1) and (var1[0] == 'T'):      # Если первый операнд в формате Tn, ...
            self.free_names.add(var1)                 # добавить его в список с освободившимися именами Tn

        if (len(var2) > 1) and (var2[0] == 'T'):      # Если второй операнд в формате Tn, ...
            self.free_names.add(var2)                 # добавить его в список с освободившимися именами Tn

        if self.free_names.head:                      # Если в списке освободившихся Tn что-то есть,
            return self.free_names.pop(0)             # то вернуть первый элемент

        temp_var = f'T{self.n}'                       # Если освободившихся имён нет, то создать и вернуть новое имя,
        self.n += 1                                   # исходя из "self.n". Так-же увеличить "self.n" на 1
        return temp_var

    def generate_instructions(self, new_data=None):   # Генератор инструкций для новопришедшего элемента
        if not (new_data in '*/+-'):                  # Если это операнд, то просто добавить его в стек
            self.list.push(new_data)
            return ''                                 # Возвращаем пустую строку

        else:                                         # Если это операция...
            if new_data == '+':
                operation = 'AD'
            elif new_data == '-':
                operation = 'SB'
            elif new_data == '*':
                operation = 'ML'
            else:
                operation = 'DV'

            variable_2 = self.list.pop(0)          # Получить последние 2 операнда (последний пришедший в начале списка)
            variable_1 = self.list.pop(0)
            if variable_1 is None:                    # В стеке не хватает операндов, вызвать ошибку и окончить работу
                raise Exception(f'Во время работы программы произошла ошибка из-за нехватки переменных для работы.\n'
                                f'Такая ошибка происходит, например, когда на вход программе подано такое выражение: '
                                f'"A+", вместо такого "AB+".\nПерепроверьте ваше выражение и введите его корректно.')

            temp_var = self.get_name_of_temp_var(variable_1, variable_2)   # Получить имя для временной переменной

            line = f'LD {variable_1}\n{operation} {variable_2}\nST {temp_var}\n'   # Перечень инструкций
            self.list.push(temp_var)
            return line                               # Возвращаем перечень инструкций


def main(input_data):                                 # Главная функция, на входе получает выражение в постфиксной форме
    stack = Stack()
    line = ''

    for i in input_data:                              # Проходимся по каждому элементу в строке входных данных
        line += stack.generate_instructions(i)        # В line дописываем результат функции (конкретные инструкции)

    res_line = ''                                     # Создание переменной для итогового ответа пользователю

    try:                                              # Проверка на то, остались ли элементы в стеке,
        current = stack.list.head.next                # в норме останется только один элемент
        if current:                                   # Если элементов в стеке осталось больше одного, ...
            res_line = f'\nПрограмма окончила работу с лишним(и) операндом(ами) в регистре: '
            while current:                            # ... то сообщим об этом в итоговом ответе
                res_line += f'"{current.data}", '
                current = current.next
            res_line = (f'{res_line[:-2]}.\n'
                        f'Это связано с излишним их количеством на входе (например, было подано выражение "ABC+").\n'
                        f'Совет: В случае, если вы не уверены в корректности вашего запроса - перепроверьте выражение, '
                        f'которое было подано программе на вход и запросите новый результат!\n')

    except AttributeError:                            # Ошибка произошла из-за отсутствия в стеке даже одного элемента,
        raise Exception('Результат отсутствует!\n'    # такое происходит при пустых входных данных
                        'Пожалуйста, перепроверьте корректность вашего выражения и запросите новый результат.')

    for i in range(len(line) - 2, -1, -1):            # Т.к. согласно условию результат вычислений остаётся в регистре,
        if (line[i] == 'S') and (line[i + 1] == 'T'):            # нужно избавиться от последней инструкции ST
            res_line += f'\nРезультат:\n{line[:i].strip()}'      # В переменную с конечным ответом записываем результат
            print(res_line)                                      # Сообщить пользователю итог (перечень инструкций)
            return                                               # Программа прекращает цикл работы

    print('Результат отсутствует!\n'                  # Некорректный ввод данных от пользователя, закончить цикл работы
          'Пожалуйста, перепроверьте корректность вашего выражения и запросите новый результат.')
    return


if __name__ == '__main__':
    user_input = input('\nВведите выражение в постфиксной форме (пример: ABC*+): ')   # Ввод пользователя
    while True:
        try:
            main(user_input)                          # Начало работы с данными от пользователя
        except Exception as ex:                       # В случае ошибки, о ней сообщаем пользователю
            print(ex)
        finally:                                      # Вне зависимости от результата, просим новое выражение
            user_input = input('\n----------------------------------------------------------------'
                               '----------------------------------------------------------------\n'
                               '\nВведите новое выражение: ')


# Пример входных данных: ABC*+DE-/
# Выходные данные:
# Результат:
# LD B
# ML C
# ST T1
# LD A
# AD T1
# ST T1
# LD D
# SB E
# ST T2
# LD T1
# DV T2

# Пример входных данных: ABC+
# Выходные данные:
# Программа окончила работу с лишним(и) операндом(ами) в регистре: "A".
# Это связано с излишним их количеством на входе (например, было подано выражение "ABC+").
# Совет: В случае, если вы не уверены в корректности вашего запроса - перепроверьте выражение,
# которое было подано программе на вход и запросите новый результат!

# Пример входных данных: +
# Выходные данные:
# Во время работы программы произошла ошибка из-за нехватки переменных для работы.
# Такая ошибка происходит, например, когда на вход программе подано такое выражение: "A+", вместо такого "AB+".
# Перепроверьте ваше выражение и введите его корректно.

# Пример входных данных: AB
# Выходные данные:
# Результат отсутствует!
# Пожалуйста, перепроверьте корректность вашего выражения и запросите новый результат.
